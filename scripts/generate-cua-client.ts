#!/usr/bin/env bun

import { mkdir, writeFile } from 'node:fs/promises';
import path from 'node:path';

type GeneratorOptions = {
  baseUrl: string;
  outDir: string;
};

type CommandCatalog = {
  commands?: Record<
    string,
    {
      params?: Array<{
        name?: string;
        required?: boolean;
        default?: unknown;
      }>;
      aliases?: string[];
    }
  >;
  aliases?: Record<string, string>;
};

function parseArgs(argv: string[]): GeneratorOptions {
  const options: Partial<GeneratorOptions> = {};
  for (let i = 0; i < argv.length; i += 1) {
    const current = argv[i];
    if (current === '--base-url' && argv[i + 1]) {
      options.baseUrl = argv[i + 1];
      i += 1;
      continue;
    }
    if (current === '--out-dir' && argv[i + 1]) {
      options.outDir = argv[i + 1];
      i += 1;
      continue;
    }
    throw new Error(`Unknown or incomplete argument: ${current}`);
  }

  const defaultBaseUrl = `http://127.0.0.1:${process.env.CUA_SANDBOX_COMMAND_PORT || '8000'}`;
  return {
    baseUrl: options.baseUrl || process.env.CUA_OPENAPI_BASE_URL || defaultBaseUrl,
    outDir:
      options.outDir ||
      path.resolve(process.cwd(), 'src/generated'),
  };
}

async function fetchJson(url: string): Promise<unknown> {
  const response = await fetch(url);
  if (!response.ok) {
    const body = await response.text();
    throw new Error(`Request failed (${response.status}) for ${url}: ${body.slice(0, 500)}`);
  }
  return response.json();
}

function normalizeCommandCatalog(input: unknown): CommandCatalog {
  const catalog = (input || {}) as CommandCatalog;
  const commands = Object.fromEntries(
    Object.entries(catalog.commands || {}).sort(([a], [b]) => a.localeCompare(b)),
  );
  const aliases = Object.fromEntries(
    Object.entries(catalog.aliases || {}).sort(([a], [b]) => a.localeCompare(b)),
  );
  return { commands, aliases };
}

async function runOpenApiTypescript(openapiPath: string, outPath: string): Promise<void> {
  const proc = Bun.spawn(
    ['bunx', '--bun', 'openapi-typescript', openapiPath, '--output', outPath],
    {
      stdout: 'inherit',
      stderr: 'inherit',
      cwd: process.cwd(),
    },
  );
  const exitCode = await proc.exited;
  if (exitCode !== 0) {
    throw new Error(`openapi-typescript failed with exit code ${exitCode}`);
  }
}

async function main(): Promise<void> {
  const options = parseArgs(process.argv.slice(2));
  await mkdir(options.outDir, { recursive: true });

  const openapiUrl = `${options.baseUrl.replace(/\/$/, '')}/openapi.json`;
  const commandsUrl = `${options.baseUrl.replace(/\/$/, '')}/commands`;

  const [openapiSpec, commandCatalogRaw] = await Promise.all([
    fetchJson(openapiUrl),
    fetchJson(commandsUrl),
  ]);
  const commandCatalog = normalizeCommandCatalog(commandCatalogRaw);

  const openapiJsonPath = path.join(options.outDir, 'cua-openapi.json');
  const commandCatalogPath = path.join(options.outDir, 'cua-commands.generated.ts');
  const openapiTypesPath = path.join(options.outDir, 'cua-openapi.generated.ts');

  await writeFile(openapiJsonPath, `${JSON.stringify(openapiSpec, null, 2)}\n`, 'utf8');
  await runOpenApiTypescript(openapiJsonPath, openapiTypesPath);

  const generatedCommandsTs = `/* eslint-disable */
// AUTO-GENERATED by scripts/generate-cua-client.ts
// Do not edit by hand.

export const CUA_COMMAND_CATALOG = ${JSON.stringify(commandCatalog, null, 2)} as const;
export type CuaKnownCommand = keyof typeof CUA_COMMAND_CATALOG.commands;
`;
  await writeFile(commandCatalogPath, generatedCommandsTs, 'utf8');

  // eslint-disable-next-line no-console
  console.log(`Generated CUA artifacts:
- ${openapiJsonPath}
- ${openapiTypesPath}
- ${commandCatalogPath}`);
}

main().catch((error: unknown) => {
  // eslint-disable-next-line no-console
  console.error(error instanceof Error ? error.message : String(error));
  process.exit(1);
});
